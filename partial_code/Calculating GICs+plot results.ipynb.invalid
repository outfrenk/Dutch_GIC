{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "import pandas as pd\n",
    "import math\n",
    "# import scipy.sparse as sps"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.9127810446661897e-11\n"
     ]
    }
   ],
   "source": [
    "path='/usr/people/out/Documents/380+220kV_extended'\n",
    "kabels=pd.read_csv(path+'/spreadsheetcables.csv', delimiter = ';')\n",
    "trafo=pd.read_csv(path+'/spreadsheettrafo.csv', delimiter = ';')\n",
    "\n",
    "###### make some matrices #######\n",
    "trafo_connect=np.zeros((len(trafo),len(trafo))) #connectivity trafo\n",
    "trafo_all_connections=np.zeros((len(trafo),len(kabels))) #connections possible between trafo and every cable\n",
    "trafo_cond=np.zeros((len(trafo),len(trafo))) # The conductivity matrix\n",
    "stat_heading=np.zeros((len(trafo),len(trafo))) #heading stations to another\n",
    "stat_length=np.zeros((len(trafo),len(trafo))) #length between stations\n",
    "stat_voltN=np.zeros((len(trafo),len(trafo))) #voltage in North direction between stations\n",
    "stat_voltE=np.zeros((len(trafo),len(trafo))) #voltage in east direction between stations\n",
    "I_GICcable=np.zeros((len(trafo),len(trafo))) #GIC between stations(= through cables)\n",
    "\n",
    "kabel_resist=np.zeros(len(kabels))\n",
    "kabel_cond=np.zeros(len(kabels)) #gives total conductivity per connected cable segment per cable\n",
    "total_kabel_cond=np.zeros(len(kabels)) #gives total conductivity per segment for all cables\n",
    "aantal_kabels=np.zeros(len(kabels)) #aantal kabels (per fase) per traject\n",
    "station_lat=np.zeros(len(trafo)) #latitude stations in degrees\n",
    "station_lon=np.zeros(len(trafo)) #longitude stations in degrees\n",
    "station_rlat=np.zeros(len(trafo)) #now in radians\n",
    "station_rlon=np.zeros(len(trafo))\n",
    "volt_result=np.zeros(len(trafo)) # resulting voltage in nodes\n",
    "ground_cond=np.zeros(len(trafo))\n",
    "\n",
    "cable_icon=np.zeros(len(kabels)) # icon array for cable and trafo resp.\n",
    "trafo_icon=np.zeros(len(trafo))\n",
    "\n",
    "################ Determine inducted currents ######################\n",
    "# heading=np.zeros(len(kabels))\n",
    "# length=np.zeros(len(kabels))\n",
    "\n",
    "J_north=np.zeros(len(trafo))\n",
    "J_east=np.zeros(len(trafo))\n",
    "\n",
    "# set electric field at 1V/1000m for now in North and East direction \n",
    "E_north=1/1000.\n",
    "E_east=1/1000.\n",
    "\n",
    "###################################################################\n",
    "##### connect trafo and cable number to position in matrix #####\n",
    "for line in range(len(kabels)):\n",
    "    cable_icon[line]=kabels.at[line,'kabelnr']\n",
    "for line in range(len(trafo)):\n",
    "    trafo_icon[line]=trafo.at[line,'trafonr']\n",
    "\n",
    "\n",
    "##### make trafo-trafo connectivity matrix ###### CORRECT\n",
    "for line in range(len(trafo)): \n",
    "    temp=trafo.at[line,'verbonden trafo'] #get right column\n",
    "    temp=temp.split(\",\") #split values\n",
    "    \n",
    "    for item in temp:\n",
    "        temp2=int(item)\n",
    "        trafo_connect[line,np.where(trafo_icon == temp2)[0]]=True #check for connection other trafo\n",
    "        del temp2\n",
    "    del temp\n",
    "\n",
    "###### make trafo-cable connectivity matrix ###### CORRECT\n",
    "#all connection\n",
    "for line in range(len(trafo)):\n",
    "    temp=trafo.at[line,'alle aansluitingen']\n",
    "    temp=temp.split(\",\")\n",
    "    for item in temp:\n",
    "        temp2=int(item)\n",
    "        trafo_all_connections[line,np.where(cable_icon == temp2)[0]]=True\n",
    "        del temp2\n",
    "    del temp\n",
    "    \n",
    "###### make total conductivity vector for cables####### CORRECT\n",
    "for line in range(len(kabels)):\n",
    "    kabel_cond[line]=float(kabels.at[line,'conductivity old'])\n",
    "    kabel_resist[line]=1/kabel_cond[line]\n",
    "for line in range(len(kabels)):\n",
    "#     aantal_kabels[line]=1\n",
    "    aantal_kabels[line]=kabels.at[line,'kab/3'] #get amount of cables per traject\n",
    "    total_kabel_cond[line]=aantal_kabels[line]*kabel_cond[line] #conductivity per cabletraject\n",
    "    \n",
    "\n",
    "##### now conductivity matrix ##### \n",
    "for row,line in enumerate(trafo_connect):\n",
    "    station_lat[row]=trafo.at[row,'lat'] # get trafostation latitude and longitude\n",
    "    station_lon[row]=trafo.at[row,'lon'] \n",
    "    station_rlat[row]=np.radians(station_lat[row]) #get trafostation latitude and longitude in radians\n",
    "    station_rlon[row]=np.radians(station_lon[row])\n",
    "        \n",
    "    for column,item in enumerate(line):\n",
    "        if item:\n",
    "            \n",
    "            temp=trafo_all_connections[row,:]+trafo_all_connections[column,:]\n",
    "            temp2=0\n",
    "            \n",
    "            for counter,value in enumerate(temp):\n",
    "                if value == 2: # if 2 then we have found the connecting cables\n",
    "                    temp2+=1/total_kabel_cond[counter]  #because of serieschain we have to add 1/sigma\n",
    "            if temp2==0:\n",
    "                print(row,column)\n",
    "            trafo_cond[row,column]=-1/temp2 #add cable resistance to off-diagonal\n",
    "            trafo_cond[row,row]+=1/temp2 #add cable resistance to trace\n",
    "            del temp, temp2\n",
    "\n",
    "# add grounding conductivity to trace            \n",
    "for line in range(len(trafo_connect)):\n",
    "    ground_cond[line]=trafo.at[line,'conductivity total']\n",
    "    trafo_cond[line,line]+=trafo.at[line,'conductivity total']\n",
    "    \n",
    "    \n",
    "################### total induced currents for stationary field ##########################\n",
    "for row,line in enumerate(trafo_connect): #get heading and length between stations\n",
    "    for column,item in enumerate(line):\n",
    "        if item and column>=row:\n",
    "            temp=math.cos(station_rlat[column])*math.sin(station_rlon[column]-station_rlon[row])\n",
    "            temp2=math.cos(station_rlat[row])*math.sin(station_rlat[column])-math.sin(station_rlat[row])*math.cos(station_rlat[column])*math.cos(station_rlon[column]-station_rlon[row])\n",
    "            stat_heading[row,column]=np.abs(math.degrees(math.atan(temp/temp2)))\n",
    "            \n",
    "            temp3=math.sin((station_rlat[column]-station_rlat[row])/2.)**2+math.cos(station_rlat[row])*math.cos(station_rlat[column])*math.sin((station_rlon[column]-station_rlon[row])/2.)**2\n",
    "            stat_length[row,column]=6371000*2*math.atan(np.sqrt(temp3)/np.sqrt(1-temp3))\n",
    "            \n",
    "            stat_heading[column,row]=stat_heading[row,column]\n",
    "            stat_length[column,row]=stat_length[row,column]\n",
    "\n",
    "for row,line in enumerate(trafo_connect):\n",
    "    for column,item in enumerate(line):\n",
    "        if item:            # get voltage between stations\n",
    "            signlat=np.sign(station_lat[row]-station_lat[column])\n",
    "            signlon=np.sign(station_lon[row]-station_lon[column])\n",
    "            stat_voltN[row,column]=signlat*E_north*np.cos(math.radians(stat_heading[row,column]))*stat_length[row,column]\n",
    "            stat_voltE[row,column]=signlon*E_east*np.sin(math.radians(stat_heading[row,column]))*stat_length[row,column]\n",
    "            \n",
    "            J_north[row]+=stat_voltN[row,column]*trafo_cond[row,column]*-1*-1 #-1*-1 because trafo_cond is negative\n",
    "            J_east[row]+=stat_voltE[row,column]*trafo_cond[row,column]*-1*-1 # and 1V/km N = x A in southern direction\n",
    "            \n",
    "J_total=J_north+J_east\n",
    "\n",
    "##### Apply the inversion #####\n",
    "trafo_icond=np.linalg.inv(trafo_cond)\n",
    "Volt_result=np.linalg.solve(trafo_cond,J_east)\n",
    "I_GIC=Volt_result*ground_cond # GIC ground NIET DELEN\n",
    "# print(Volt_result, I_GIC)\n",
    "\n",
    "for row,line in enumerate(trafo_connect):\n",
    "    for column,item in enumerate(line):\n",
    "        if item and column>=row:\n",
    "            I_GICcable[row,column]=(Volt_result[row]-Volt_result[column])*trafo_cond[row,column]*-1\n",
    "            I_GICcable[column,row]=-1*I_GICcable[row,column]\n",
    "print(np.sum(I_GIC))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "29\n",
      "[-3.33970874e+00 -2.59414033e+00 -5.05446197e+00  6.68592656e+00\n",
      "  9.77866717e+00  1.08506085e+01  1.00590696e+01  9.83001414e+00\n",
      "  1.36455638e+01  1.30997925e+01  6.27277319e+00  7.06117097e+00\n",
      "  5.03616274e+00  8.51844779e+00  9.77033286e+00  1.08846695e+01\n",
      "  1.36645878e+01  1.00659861e+01  2.87392115e+00  5.85664873e+00\n",
      "  2.42318564e+01  1.23964464e+01  1.19741732e+01  1.19833367e+01\n",
      "  6.76075554e+00  5.55160268e+00  3.29221496e+00  6.89788622e-02\n",
      " -9.68230346e-01 -2.14462917e+00  2.46949570e+00  2.40460730e+00\n",
      "  1.57149951e+01  8.56342123e+00  3.05509420e+00 -6.57182951e-01\n",
      " -4.18391402e+00 -3.65733506e+00 -3.34561176e+00 -3.48678729e+00\n",
      " -2.37952514e+00 -1.97525803e+00 -1.14840133e+01  5.20781695e-08\n",
      "  5.12898112e+00  6.78054086e-08 -1.90598391e+00 -9.27393762e-01\n",
      "  1.65101191e+00  8.87442957e+00  1.14233155e+01  9.96990416e+00\n",
      " -3.96970887e+00  2.41797203e+00 -1.34011309e+01 -1.06684943e+01\n",
      " -1.07201385e-07 -1.96056800e-07 -1.95888351e+01 -2.81078490e+01\n",
      " -1.47081949e+01 -1.22243150e+01 -1.09550602e+01 -7.46464880e+00\n",
      " -1.52353538e+01 -1.92494248e+01 -2.88004751e+01  1.67496637e+00\n",
      "  1.68729158e-08 -7.59126689e+00 -1.42630603e-07 -1.17943681e+01\n",
      " -1.75632754e+01 -2.36724461e+01 -7.18939850e+00 -6.56818394e+00\n",
      "  8.82591702e-01 -7.83120286e-08 -7.83533880e+00 -5.39004686e+00\n",
      " -3.04760531e-08 -2.88262378e+00 -3.20130039e+00  1.61407309e-01\n",
      " -6.47018755e-09 -7.86285316e-01  7.42002569e-01  2.70877394e+00\n",
      "  2.16455774e+00  4.31528497e+00 -1.44231548e+00  3.84073670e+00\n",
      "  1.20010255e-08  3.42010670e+00  1.94044779e+00  3.84437985e+00\n",
      "  1.75250719e+00 -2.84680543e+00 -1.32679847e-01 -2.92457013e+00\n",
      " -4.17513567e-01 -1.91474318e+01 -7.46957448e+00 -5.46971504e+00\n",
      " -2.51172103e+01 -2.98581257e+01 -2.28014518e+01 -4.41217431e+00\n",
      " -8.17930260e+00 -2.49560928e+01 -1.11816277e+01 -1.39160682e+01\n",
      " -1.39844886e-07 -2.66218290e+01  5.89823935e+00  8.71012324e+00\n",
      "  1.69176605e-08  1.70812079e+00  4.21770236e+00 -2.91024995e+00\n",
      " -6.36340318e+00 -1.19290737e+01 -1.02039315e+00  2.39998231e+01\n",
      "  2.01117072e-07  2.01530075e+01  1.26170715e-07  7.92646585e+00\n",
      "  1.31048160e+01  1.14487559e-08  2.43327811e+00 -2.90317033e+00\n",
      "  2.42573507e-01  5.87398804e-01 -3.92591907e+00 -1.15290781e+01\n",
      " -7.98679513e+00  3.89391740e+00  1.28719388e+01  5.31409436e+00\n",
      "  1.05736152e-07  9.39282637e+00  1.34056651e+01  1.37386353e+01\n",
      "  1.39247479e-07  1.17437238e+01  9.67176946e+01 -2.97997142e+00\n",
      " -1.38086692e-07]\n"
     ]
    }
   ],
   "source": [
    "absAMP=abs(I_GIC[0:-3])\n",
    "maxAMP=np.max(absAMP) #amperes for 1 cm\n",
    "maxAMP=int(maxAMP)\n",
    "print(maxAMP)\n",
    "print(I_GIC)\n",
    "##### Save files #######\n",
    "GIC=pd.DataFrame(columns=['lon','lat','GIC',f'GIC/{maxAMP}'])\n",
    "GICmatrix=pd.DataFrame()\n",
    "for i in range(len(trafo_connect)):\n",
    "    GIC.at[i,'lon']=station_lon[i]\n",
    "    GIC.at[i,'lat']=station_lat[i]\n",
    "    GIC.at[i,'GIC']=I_GIC[i]\n",
    "    GIC.at[i,f'GIC/{maxAMP}']=I_GIC[i]/maxAMP\n",
    "    GICmatrix[i]=I_GICcable[i,:]\n",
    "GIC.to_csv(path_or_buf=f'{path}/GIC_trafo.csv', sep=';', index=False, header=True)\n",
    "GICmatrix.to_csv(path_or_buf=f'{path}/GIC_cable.csv', sep=';', index=False, header=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# lim1=np.min(station_lon)-0.75\n",
    "# lim2=np.max(station_lon)+0.75\n",
    "# lim3=np.min(station_lat)-0.75\n",
    "# lim4=np.max(station_lat)+0.75\n",
    "# lim1=3.3\n",
    "# lim2=9.6\n",
    "# lim3=49\n",
    "# lim4=54\n",
    "lim1=3.3\n",
    "lim2=7.5\n",
    "lim3=50.5\n",
    "lim4=54\n",
    "\n",
    "legendlon=lim2-1\n",
    "legendlat=lim4-0.1\n",
    "textlon=legendlon+0.6\n",
    "textlat=legendlat\n",
    "\n",
    "\n",
    "legend=open('legend.txt','w+')\n",
    "legend.write(f'{legendlon} {legendlat} 1 1')\n",
    "legend.close()\n",
    "legendtxt=open('legendtext.txt', 'w+')\n",
    "legendtxt.write(f'{textlon} {textlat} {maxAMP} A')\n",
    "legendtxt.close()\n",
    "\n",
    "##### Use GMT to plot GICs ######\n",
    "direction='TEST'\n",
    "proj='-JM15C -P'\n",
    "lims=f'-R{lim1}/{lim2}/{lim3}/{lim4}'\n",
    "psfile=f'{path}/380+220kVGIC{direction}.ps' #aanpassen\n",
    "pngfile=f'{path}/380+220kVGIC{direction}.png' #aanpassen\n",
    "os.system(f'gmt pscoast {proj} {lims} -W0.5p -K -Ggrey -Slightblue -Df -N1/0.25p> {psfile}' )\n",
    "os.system(f'gmt psbasemap {proj} {lims} -Ba1g1 -BWeSn+t\"GIC {direction}\" -O -K>> {psfile}' )\n",
    "# os.system(f'gmt psxy {path}/trafo.csv {proj} {lims} -Ss0.1c -Wblack -O -K>> {psfile}')\n",
    "os.system(f'gmt psxy {path}/GIC_trafo.csv {proj} {lims} -Ctopo.cpt -Scc -O -K>> {psfile}')\n",
    "# os.system(f'gmt psxy {path}/cables220.csv {proj} {lims} -W0.5p -Wred -O -K>> {psfile}' )\n",
    "os.system(f'gmt psxy {path}/cables.csv {proj} {lims} -W0.5p -Wred -O -K>> {psfile}' )\n",
    "os.system(f'gmt psxy legend.txt {proj} {lims} -Ctopo.cpt -W -Scc -O -K>> {psfile}')\n",
    "os.system(f'gmt pstext legendtext.txt {proj} {lims} -F+f20pHelvetica,black -O>> {psfile}')\n",
    "os.system(f'convert -density 300 {psfile} {pngfile}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1, 1], [2, 1], [1, 2], [2, 2]]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([0.7])"
      ]
     },
     "execution_count": 50,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# if we would have a gridded electric field, this interpolation technique could be used\n",
    "from scipy.interpolate import griddata\n",
    "listt=[[1,1],[2,1],[1,2],[2,2]]\n",
    "values=[0,1,1,3]\n",
    "interpolationpoints=[1.3,1.2]\n",
    "print(listt)\n",
    "griddata(listt,values,interpolationpoints,method='linear')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Directory has already been created, data could be destroyed!\n",
      "New data is added now!\n",
      "Thread 1 is acquiring potential for timestep 0!\n",
      "Script has been completed!\n"
     ]
    }
   ],
   "source": [
    "# obtain real voltages per cable piece and execute total code\n",
    "import os\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import math\n",
    "import logging\n",
    "from scipy.interpolate import griddata\n",
    "from threading import local\n",
    "localvar=local()\n",
    "from multiprocessing import Process\n",
    "from multiprocessing import Lock\n",
    "lock=Lock()\n",
    "path='/usr/people/out/Documents/Magnetic_field/station_results/31-10-2003'\n",
    "logging.basicConfig(filename=f'{path}/GIClogbook.log', level=logging.DEBUG, format='%(asctime)s %(message)s')\n",
    "#################################### first reading in datasets #####################################################\n",
    "try:\n",
    "    os.mkdir(f'{path}/GIC')\n",
    "except:\n",
    "    logging.warning(\"Directory has already been created, data could be destroyed!\")\n",
    "    print(\"Directory has already been created, data could be destroyed!\")\n",
    "logging.info('Reading in datasets!')\n",
    "Electric_Xfiles=[]\n",
    "Electric_Yfiles=[]\n",
    "os.system(f' ls {path}/electric_field_north/*.csv > {path}/temp.txt')\n",
    "f=open(f'{path}/temp.txt')\n",
    "for item in f:\n",
    "    item=item.strip('\\n')\n",
    "    Electric_Xfiles.append(item)\n",
    "f.close()\n",
    "os.system(f' ls {path}/electric_field_east/*.csv > {path}/temp.txt')\n",
    "f=open(f'{path}/temp.txt')\n",
    "for item in f:\n",
    "    item=item.strip('\\n')\n",
    "    Electric_Yfiles.append(item)\n",
    "f.close()\n",
    "os.system(f'rm {path}/temp.txt')\n",
    "\n",
    "for counter,file in enumerate(Electric_Xfiles):\n",
    "    Xfile=pd.read_csv(file, delimiter=' ', header=None)\n",
    "    values=Xfile.to_numpy()\n",
    "    break\n",
    "EX_matrix=np.zeros((len(Electric_Xfiles),len(values)))    \n",
    "EY_matrix=np.zeros((len(Electric_Xfiles),len(values)))\n",
    "    \n",
    "for counter,file in enumerate(Electric_Xfiles):\n",
    "    Xfile=pd.read_csv(file, delimiter=' ', header=None)\n",
    "    values=Xfile.to_numpy()\n",
    "    EX_matrix[counter,:]=values[:,2]\n",
    "lat=values[:,1]\n",
    "lon=values[:,0]\n",
    "for counter,file in enumerate(Electric_Yfiles):\n",
    "    Yfile=pd.read_csv(file, delimiter=' ', header=None)\n",
    "    values=Yfile.to_numpy()\n",
    "    EY_matrix[counter,:]=values[:,2]\n",
    "del item, f, Xfile, values, Yfile\n",
    "\n",
    "######################################### Getting the needed GIC matrices and code #################################\n",
    "logging.info('Starting with the GIC code!')\n",
    "path2='/usr/people/out/Documents/380+220kV_extended'\n",
    "kabels=pd.read_csv(path2+'/spreadsheetcables.csv', delimiter = ';')\n",
    "trafo=pd.read_csv(path2+'/spreadsheettrafo.csv', delimiter = ';')\n",
    "trafo_connect=np.zeros((len(trafo),len(trafo))) #connectivity trafo\n",
    "trafo_all_connections=np.zeros((len(trafo),len(kabels))) #connections possible between trafo and every cable\n",
    "trafo_cond=np.zeros((len(trafo),len(trafo))) # The conductivity matrix\n",
    "stat_heading=np.zeros((len(trafo),len(trafo))) #heading stations to another\n",
    "stat_length=np.zeros((len(trafo),len(trafo))) #length between stations\n",
    "station_lat=np.zeros(len(trafo)) #latitude stations in degrees\n",
    "station_lon=np.zeros(len(trafo)) #longitude stations in degrees\n",
    "ground_cond=np.zeros(len(trafo))\n",
    "cable_icon=np.zeros(len(kabels)) # icon array for cable and trafo resp.\n",
    "trafo_icon=np.zeros(len(trafo))\n",
    "\n",
    "##### connect trafo and cable number to position in matrix #####\n",
    "for line in range(len(kabels)):\n",
    "    cable_icon[line]=kabels.at[line,'kabelnr']\n",
    "for line in range(len(trafo)):\n",
    "    trafo_icon[line]=trafo.at[line,'trafonr']\n",
    "##### make trafo-trafo connectivity matrix ######\n",
    "for line in range(len(trafo)): \n",
    "    temp=trafo.at[line,'verbonden trafo'] #get right column\n",
    "    temp=temp.split(\",\") #split values\n",
    "    \n",
    "    for item in temp:\n",
    "        temp2=int(item)\n",
    "        trafo_connect[line,np.where(trafo_icon == temp2)[0]]=True #check for connection other trafo\n",
    "        del temp2\n",
    "    del temp\n",
    "###### make trafo-cable connectivity matrix ######\n",
    "for line in range(len(trafo)):\n",
    "    temp=trafo.at[line,'alle aansluitingen']\n",
    "    temp=temp.split(\",\")\n",
    "    for item in temp:\n",
    "        temp2=int(item)\n",
    "        trafo_all_connections[line,np.where(cable_icon == temp2)[0]]=True\n",
    "        del temp2\n",
    "    del temp\n",
    "###### make conductivity matrix ######\n",
    "for row,line in enumerate(trafo_connect):\n",
    "    trafo_cond[row,row]=trafo.at[row,'conductivity total']\n",
    "    for column,item in enumerate(line):\n",
    "        if item:\n",
    "            temp=trafo_all_connections[row,:]+trafo_all_connections[column,:]\n",
    "            temp2=0\n",
    "            for counter,value in enumerate(temp):\n",
    "                if value == 2: # if 2 then we have found the connecting cables\n",
    "                    temp2+=1/(float(kabels.at[counter,'conductivity'])*kabels.at[counter,'kab/3'])  #because of serieschain we have to add 1/sigma\n",
    "#             if temp2==0:\n",
    "#                 print(row,column)\n",
    "            trafo_cond[row,column]=-1/temp2 #add cable resistance to off-diagonal\n",
    "            trafo_cond[row,row]+=1/temp2 #add cable resistance to trace\n",
    "            del temp, temp2\n",
    "###### get heading and length between stations #####\n",
    "for row,line in enumerate(trafo_connect):\n",
    "    for column,item in enumerate(line):\n",
    "        if item and column>=row:\n",
    "            Alat=np.radians(trafo.at[row,'lat'])\n",
    "            Alon=np.radians(trafo.at[row,'lon'])\n",
    "            Blat=np.radians(trafo.at[column,'lat'])\n",
    "            Blon=np.radians(trafo.at[column,'lon'])\n",
    "            temp=math.cos(Blat)*math.sin(Blon-Alon)\n",
    "            temp2=math.cos(Alat)*math.sin(Blat)-math.sin(Alat)*math.cos(Blat)*math.cos(Blon-Alon)\n",
    "            stat_heading[row,column]=np.abs(math.degrees(math.atan(temp/temp2)))\n",
    "            temp3=math.sin((Blat-Alat)/2.)**2+math.cos(Alat)*math.cos(Blat)*math.sin((Blon-Alon)/2.)**2\n",
    "            stat_length[row,column]=6371000*2*math.atan(np.sqrt(temp3)/np.sqrt(1-temp3))\n",
    "            stat_heading[column,row]=stat_heading[row,column]\n",
    "            stat_length[column,row]=stat_length[row,column]\n",
    "            del temp, temp2, temp3, Alat, Alon, Blat, Blon\n",
    "del line, item, row, column, value, counter\n",
    "######### get necessary arrays ########\n",
    "for item in range(len(trafo)):\n",
    "    station_lat[item]=trafo.at[item,'lat']\n",
    "    station_lon[item]=trafo.at[item,'lon']\n",
    "    ground_cond[item]=trafo.at[item,'conductivity total']\n",
    "\n",
    "############################### Run the function with multiple processors ##########################################\n",
    "logging.info('Start multiprocessing!')\n",
    "print(\"New data is added now!\")\n",
    "n=1\n",
    "nrsteps=int(1/n)\n",
    "threads=list()\n",
    "for index in range(n):\n",
    "    q=Process(target=GICfunction, args=(index+1,nrsteps*index,nrsteps*(index+1),trafo,EX_matrix,EY_matrix,lat,lon,station_lat,station_lon,trafo_connect,stat_heading,stat_length,trafo_cond,ground_cond,path,path2))\n",
    "    threads.append(q)\n",
    "    q.start()\n",
    "for thread in threads:\n",
    "    thread.join()\n",
    "logging.info(\"Script has been completed!\")\n",
    "print(\"Script has been completed!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "def GICfunction(q,begin,end,trafo,EX_matrix,EY_matrix,lat,lon,station_lat,station_lon,trafo_connect,stat_heading,stat_length,trafo_cond,ground_cond,path,path2):\n",
    "######################################### interpolation ############################################################\n",
    "    localvar.volt_result=np.zeros(len(trafo))\n",
    "    localvar.J_total=np.zeros(len(trafo))\n",
    "    localvar.grid_EX=np.zeros(len(trafo))\n",
    "    localvar.grid_EY=np.zeros(len(trafo))\n",
    "    logging.info(f'Thread {q} has started interpolation!')\n",
    "    for localvar.time in range(begin,end):#range(len(grid_EX)):\n",
    "        localvar.J_north=np.zeros(len(trafo))\n",
    "        localvar.J_east=np.zeros(len(trafo))\n",
    "        localvar.grid_EX=griddata((lat,lon),EX_matrix[localvar.time,:],(station_lat,station_lon),method='cubic')\n",
    "        localvar.grid_EY=griddata((lat,lon),EY_matrix[localvar.time,:],(station_lat,station_lon),method='cubic')\n",
    "#         logging.debug(f'Grid X is {localvar.grid_EX}')\n",
    "#         logging.debug(f'Grid Y is {localvar.grid_EY}')\n",
    "###################################### get electric potential between stations #####################################\n",
    "        logging.info(f'Thread {q} is acquiring potential for timestep {localvar.time}!')\n",
    "        print(f'Thread {q} is acquiring potential for timestep {localvar.time}!')\n",
    "        for localvar.row,localvar.line in enumerate(trafo_connect):\n",
    "            for localvar.column,localvar.item in enumerate(localvar.line):\n",
    "                if localvar.item:\n",
    "                    localvar.signlat=np.sign(trafo.at[localvar.row,'lat']-trafo.at[localvar.column,'lat'])\n",
    "                    localvar.signlon=np.sign(trafo.at[localvar.row,'lon']-trafo.at[localvar.column,'lon'])\n",
    "                    localvar.stat_voltN=localvar.signlat*((localvar.grid_EX[localvar.row]+localvar.grid_EX[localvar.column])/2.)*np.cos(math.radians(stat_heading[localvar.row,localvar.column]))*stat_length[localvar.row,localvar.column]\n",
    "                    localvar.stat_voltE=localvar.signlon*((localvar.grid_EY[localvar.row]+localvar.grid_EY[localvar.column])/2.)*np.sin(math.radians(stat_heading[localvar.row,localvar.column]))*stat_length[localvar.row,localvar.column]\n",
    "                    localvar.J_north[localvar.row]+=localvar.stat_voltN*trafo_cond[localvar.row,localvar.column]*-1*-1\n",
    "                    localvar.J_east[localvar.row]+=localvar.stat_voltE*trafo_cond[localvar.row,localvar.column]*-1*-1\n",
    "        localvar.J_total=localvar.J_north+localvar.J_east\n",
    "        localvar.volt_result=np.linalg.solve(trafo_cond,localvar.J_total)\n",
    "        localvar.I_GIC=localvar.volt_result*ground_cond\n",
    "        \n",
    "##################################### getting max I_GIC and writing results ########################################\n",
    "        logging.info(f'Thread {q} is writing results to files for timestep {localvar.time}!')\n",
    "        localvar.maxAMP=1\n",
    "        logging.debug(localvar.I_GIC)\n",
    "        if localvar.time<10:\n",
    "            localvar.tijd=f'000{localvar.time}'\n",
    "        elif localvar.time<100 and localvar.time>9:\n",
    "            localvar.tijd=f'00{localvar.time}'\n",
    "        elif localvar.time<1000 and localvar.time>99:\n",
    "            localvar.tijd=f'0{localvar.time}'\n",
    "        else:\n",
    "            localvar.tijd=f'{localvar.time}'\n",
    "        \n",
    "        ##### Save files #######\n",
    "        localvar.GIC=pd.DataFrame(columns=['lon','lat','GIC',f'GIC/{localvar.maxAMP}'])\n",
    "        GICmatrix=pd.DataFrame()\n",
    "        for localvar.i in range(len(trafo_connect)):\n",
    "            localvar.GIC.at[localvar.i,'lon']=station_lon[localvar.i]\n",
    "            localvar.GIC.at[localvar.i,'lat']=station_lat[localvar.i]\n",
    "            localvar.GIC.at[localvar.i,'GIC']=localvar.I_GIC[localvar.i]\n",
    "            localvar.GIC.at[localvar.i,f'GIC/{localvar.maxAMP}']=localvar.I_GIC[localvar.i]/localvar.maxAMP\n",
    "        localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/TEST{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
    "        \n",
    "################################### Plotting results ###############################################################\n",
    "        lim1=3.3\n",
    "        lim2=7.5\n",
    "        lim3=50.5\n",
    "        lim4=54\n",
    "        legendlon=lim1+0.18\n",
    "        legendlat=lim4-0.1\n",
    "        textlon=legendlon+0.40\n",
    "        textlat=legendlat-0.03\n",
    "\n",
    "        with lock:\n",
    "            legend=open(f'{path2}/legend.txt','w+')\n",
    "            legend.write(f'{legendlon} {legendlat} 1 1')\n",
    "            legend.close()\n",
    "            legendtxt=open(f'{path2}/legendtext.txt', 'w+')\n",
    "            legendtxt.write(f'{textlon} {textlat} {localvar.maxAMP}A')\n",
    "            legendtxt.close()\n",
    "\n",
    "            ##### Use GMT to plot GICs ######\n",
    "            minute=localvar.time%60\n",
    "            hour=int(localvar.time/60)\n",
    "            if minute < 10:\n",
    "                minute=f'0{minute}'\n",
    "            if hour < 10:\n",
    "                hour=f'0{hour}'\n",
    "            \n",
    "            title=f'GIC at 29-10-2003 - {hour}:{minute}'\n",
    "            proj='-JM15C -P'\n",
    "            lims=f'-R{lim1}/{lim2}/{lim3}/{lim4}'\n",
    "            psfile=f'{path}/GIC/GIC_at_{localvar.tijd}.ps' #aanpassen\n",
    "            pngfile=f'{path}/GIC/GIC_at_{localvar.tijd}.png' #aanpassen\n",
    "            os.system(f'gmt pscoast {proj} {lims} -W0.5p -K -Ggrey -Slightblue -Df -N1/0.25p> {psfile}' )\n",
    "            os.system(f'gmt psbasemap {proj} {lims} -Ba1g1 -BWeSn+t\"{title}\" -O -K>> {psfile}' )\n",
    "            os.system(f'gmt psxy {path2}/cables.csv {proj} {lims} -W0.5p -Wred -O -K>> {psfile}' )\n",
    "            os.system(f'gmt psxy {path}/GIC/GIC_{localvar.tijd}.csv {proj} {lims} -Ctopo.cpt -Scc -O -K>> {psfile}')    \n",
    "            os.system(f'gmt psxy {path2}/legend.txt {proj} {lims} -Ctopo.cpt -W -Scc -O -K>> {psfile}')\n",
    "            os.system(f'gmt pstext {path2}/legendtext.txt {proj} {lims} -F+f25pHelvetica,black -O>> {psfile}')\n",
    "        os.system(f'convert -density 300 {psfile} {pngfile}')\n",
    "        os.system(f'rm {psfile}')\n",
    "        logging.info(f'Thread {q} has fulfilled timestep {localvar.time}!')\n",
    "    logging.info(f'Thread {q} is finished!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import os\n",
    "path='/usr/people/out/Documents/Magnetic_field/station_results/31-10-2003'\n",
    "os.system(f'ffmpeg -framerate 24 -pattern_type glob -i \"{path}/GIC/GIC_at_????.png\" {path}/GIC.mp4')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[]"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "#plot one station's timeseries\n",
    "import matplotlib\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import os\n",
    "path='/usr/people/out/Documents/Magnetic_field/station_results/new_29-10-2003'\n",
    "os.system(f'ls {path}/GIC/*.csv > {path}/GIC.temp')\n",
    "f=open(f'{path}/GIC.temp')\n",
    "\n",
    "for counter,files in enumerate(f): #reading in data\n",
    "    files=files.strip('\\n')\n",
    "    newdata=pd.read_csv(files, delimiter=';')\n",
    "    numpydata=newdata.to_numpy()\n",
    "    if counter==0:\n",
    "        GIC_matrix=np.zeros((1440,len(numpydata)))\n",
    "    GIC_matrix[counter,:]=numpydata[:,2]\n",
    "os.system(f'rm {path}/GIC.temp')\n",
    "\n",
    "Time=np.linspace(0,24,1440)\n",
    "fig=plt.figure()\n",
    "ax=fig.add_subplot(111)\n",
    "ax.set_title('GIC at Eemshaven on 29-10-2003')\n",
    "ax.set_ylabel('Current (A)')\n",
    "ax.set_xlabel('Time (hours)')\n",
    "ax.plot(Time,GIC_matrix[:,0])\n",
    "plt.plot()\n",
    "fig=plt.figure()\n",
    "ax=fig.add_subplot(111)\n",
    "ax.set_title('GIC at Borssele on 29-10-2003')\n",
    "ax.set_ylabel('Current (A)')\n",
    "ax.set_xlabel('Time (hours)')\n",
    "ax.plot(Time,GIC_matrix[:,20])\n",
    "plt.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ObtainJ(kabels,EX_matrix,EY_matrix,lat,lon,time,trafo_connect):\n",
    "#     MEGACOUNTER=0\n",
    "    localvar.cablecheck=np.zeros(len(kabels))\n",
    "    localvar.E_kabels=np.zeros((len(kabels),2))         \n",
    "    localvar.E_kabels=calcE(kabels,EX_matrix,EY_matrix,lat,lon,time)\n",
    "    localvar.stat_voltN=np.zeros((len(trafo),len(trafo)))\n",
    "    localvar.stat_voltE=np.zeros((len(trafo),len(trafo)))\n",
    "    localvar.J_north=np.zeros(len(trafo))\n",
    "    localvar.J_east=np.zeros(len(trafo))\n",
    "    for localvar.row,localvar.line in enumerate(trafo_connect):\n",
    "#         NEWCOUNTER=0\n",
    "        ruleA=999\n",
    "        for localvar.column,localvar.item in enumerate(localvar.line):\n",
    "            if localvar.item:\n",
    "                for localvar.number in range(len(kabels)):\n",
    "                    localvar.cablecheck[localvar.number]=trafo_all_connections[localvar.row,localvar.number]+trafo_all_connections[localvar.column,localvar.number]\n",
    "                localvar.A=np.array(np.where(localvar.cablecheck==2)) #find indices that indicate cables connected\n",
    "\n",
    "                localvar.coord=trafo.at[localvar.row,'lat']\n",
    "#                 print(localvar.row, localvar.column, localvar.coord, localvar.A, len(localvar.A[0]))\n",
    "                for localvar.counter2 in range(len(localvar.A[0])): #double loop to check the cable connections\n",
    "#                     NEWCOUNTER+=1\n",
    "#                     MEGACOUNTER+=1\n",
    "                    for localvar.counter in range(len(localvar.A[0])):\n",
    "                        if abs(localvar.coord-kabels.at[localvar.A[0,localvar.counter],'strtlat'])<0.00001 and abs(ruleA-localvar.A[0,localvar.counter])>0.51: #check coord for which cable is connected and same cable is not allowed!\n",
    "                            localvar.coord=kabels.at[localvar.A[0,localvar.counter],'eindlat']\n",
    "                            ruleA=localvar.A[0,localvar.counter] #rule to ensure that the same cable is not picked again\n",
    "#                             MEGACOUNTER+=1\n",
    "#                             print(localvar.row,localvar.column, localvar.coord)\n",
    "                            # first North component\n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlat'] < kabels.at[localvar.A[0,localvar.counter],'eindlat']:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]*-1\n",
    "                            else:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]\n",
    "                            # now East component    \n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlon'] < kabels.at[localvar.A[0,localvar.counter],'eindlon']:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]*-1\n",
    "                            else:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]\n",
    "                            break                           \n",
    "                        elif abs(localvar.coord-kabels.at[localvar.A[0,localvar.counter],'eindlat'])<0.00001 and abs(ruleA-localvar.A[0,localvar.counter])>0.51:\n",
    "                            ruleA=localvar.A[0,localvar.counter]\n",
    "#                             MEGACOUNTER+=1\n",
    "                            localvar.coord=kabels.at[localvar.A[0,localvar.counter],'strtlat']\n",
    "#                             print(localvar.row, localvar.column, localvar.coord)\n",
    "                            # first North component\n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlat'] < kabels.at[localvar.A[0,localvar.counter],'eindlat']:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]\n",
    "                            else:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]*-1\n",
    "                            # now East component    \n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlon'] < kabels.at[localvar.A[0,localvar.counter],'eindlon']:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]\n",
    "                            else:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]*-1\n",
    "                            break\n",
    "                        else:\n",
    "                            pass\n",
    "#         print(localvar.row,NEWCOUNTER)\n",
    "#     print(f'Amount of cables is {MEGACOUNTER/2}')\n",
    "#                         else:\n",
    "#                             print(localvar.row, localvar.column, 'error')\n",
    "    for localvar.row,localvar.line in enumerate(trafo_connect):\n",
    "        for localvar.column,localvar.item in enumerate(localvar.line):\n",
    "            localvar.J_north[localvar.row]+=localvar.stat_voltN[localvar.row,localvar.column]*trafo_cond[localvar.row,localvar.column]*-1*-1 #extra -1 -1 to get J in opposite direction of E\n",
    "            localvar.J_east[localvar.row]+=localvar.stat_voltE[localvar.row,localvar.column]*trafo_cond[localvar.row,localvar.column]*-1*-1\n",
    "    return localvar.J_north, localvar.J_east"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calcE(kabels,EX_matrix,EY_matrix,lat,lon,time): #E for all cables\n",
    "    from scipy.interpolate import griddata\n",
    "    from scipy.integrate import simps\n",
    "    localvar.heading=np.zeros(len(kabels))\n",
    "    localvar.old=np.zeros((len(kabels),2))\n",
    "    nr=40 # amount of nodes\n",
    "    while True:\n",
    "        localvar.E_all=np.zeros((len(kabels),2))\n",
    "        localvar.latrange=np.zeros((len(kabels),nr))\n",
    "        localvar.lonrange=np.zeros((len(kabels),nr))\n",
    "        localvar.GridEX=np.zeros((len(kabels),nr))\n",
    "        localvar.GridEY=np.zeros((len(kabels),nr))\n",
    "    \n",
    "        for number in range(len(kabels)):\n",
    "            localvar.latrange[number,:]=np.linspace(kabels.at[number,'strtlat'],kabels.at[number,'eindlat'],nr) \n",
    "            localvar.lonrange[number,:]=np.linspace(kabels.at[number,'strtlon'],kabels.at[number,'eindlon'],nr) \n",
    "            localvar.heading[number]=kabels.at[number,'heading']\n",
    "        localvar.GridEX=griddata((lat,lon),EX_matrix[time,:],(localvar.latrange,localvar.lonrange),method='cubic') #interpolate value\n",
    "        localvar.GridEY=griddata((lat,lon),EY_matrix[time,:],(localvar.latrange,localvar.lonrange),method='cubic')\n",
    "        for number in range(len(kabels)):\n",
    "            localvar.E_all[number,0]+=abs(np.cos(np.radians(localvar.heading[number])))*simps(localvar.GridEX[number,:],np.linspace(0,kabels.at[number,'length'],nr))\n",
    "            localvar.E_all[number,1]+=abs(np.sin(np.radians(localvar.heading[number])))*simps(localvar.GridEY[number,:],np.linspace(0,kabels.at[number,'length'],nr))\n",
    "        print(nr, np.sum(abs(localvar.old-localvar.E_all)))\n",
    "        if np.sum(abs(localvar.old-localvar.E_all))<10**-5:\n",
    "            print('Iterations used', nr-1)\n",
    "            break\n",
    "        else:\n",
    "            localvar.old[:,0]=localvar.E_all[:,0]\n",
    "            localvar.old[:,1]=localvar.E_all[:,1]\n",
    "            nr+=1\n",
    "    return localvar.E_all"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "40 57.69237599076081\n",
      "41 6.037880696519738e-06\n",
      "Iterations used 40\n",
      "[[ 9.42989432e-02 -2.59435712e-02]\n",
      " [ 9.09133930e-02 -3.27485839e-02]\n",
      " [ 2.71771721e-02 -1.02343062e-01]\n",
      " [ 5.73622581e-03 -2.21413366e-02]\n",
      " [ 2.76492019e-01 -4.43910738e-02]\n",
      " [ 1.59124096e-01 -2.64502737e-01]\n",
      " [ 6.26773989e-02 -1.86281938e-01]\n",
      " [ 2.84316795e-02 -1.26957775e-01]\n",
      " [ 9.56468055e-02 -1.12319404e-03]\n",
      " [ 5.61500529e-02 -9.21788910e-02]\n",
      " [ 3.64343043e-02 -1.08769715e-01]\n",
      " [ 6.58213858e-02 -7.03802534e-02]\n",
      " [ 3.44236366e-02 -1.07759896e-01]\n",
      " [ 8.36973029e-02 -9.71910638e-03]\n",
      " [ 1.09022443e-01 -1.16574326e-01]\n",
      " [ 1.45181752e-01 -4.00805601e-02]\n",
      " [ 1.01071957e-01 -1.44107184e-01]\n",
      " [ 1.17449140e-01 -1.29551786e-02]\n",
      " [ 1.66805889e-01 -1.90974861e-01]\n",
      " [ 9.77903441e-02 -6.90703346e-02]\n",
      " [ 2.99573408e-02 -7.61307724e-02]\n",
      " [ 5.91673690e-02 -3.72928707e-02]\n",
      " [ 2.22537362e-02 -4.44619008e-02]\n",
      " [ 3.16024065e-02 -6.88697784e-02]\n",
      " [ 2.53981976e-03 -8.09633024e-02]\n",
      " [ 9.47024321e-02 -1.65202717e-01]\n",
      " [ 4.44072348e-02 -1.53312935e-01]\n",
      " [ 5.79335819e-02 -1.44432826e-01]\n",
      " [ 7.26042485e-02 -6.90515404e-02]\n",
      " [ 5.71397957e-02 -1.12161548e-01]\n",
      " [ 1.02073143e-01 -1.77527489e-02]\n",
      " [ 6.19044111e-02 -1.94488355e-01]\n",
      " [ 1.50254690e-01 -3.64549016e-02]\n",
      " [ 3.63532975e-02 -2.13633780e-01]\n",
      " [ 3.04588025e-02 -2.15730770e-01]\n",
      " [ 1.93394168e-02 -1.34626078e-01]\n",
      " [ 2.23824863e-02 -1.33530001e-01]\n",
      " [ 3.84220510e-02 -1.26389442e-01]\n",
      " [ 8.19682914e-02 -2.57524107e-01]\n",
      " [ 2.01881174e-01 -7.10033147e-03]\n",
      " [ 4.08473131e-02 -5.42362760e-03]\n",
      " [ 1.37399729e-01 -6.37674318e-03]\n",
      " [ 2.83780152e-02 -1.84871978e-01]\n",
      " [ 6.29072725e-02 -8.65752057e-02]\n",
      " [ 6.14374903e-02 -2.76020170e-01]\n",
      " [ 4.73446528e-02 -2.45773508e-01]\n",
      " [ 2.48755140e-02 -2.49598315e-01]\n",
      " [ 1.94675090e-02 -9.14364004e-02]\n",
      " [ 1.32258985e-01 -8.89818724e-02]\n",
      " [ 1.63583630e-02 -2.02942996e-01]\n",
      " [ 1.97548773e-01 -4.57378906e-01]\n",
      " [ 1.77990637e-01 -2.07145606e-01]\n",
      " [ 3.61986913e-02 -2.04183323e-01]\n",
      " [ 2.11049517e-01 -3.77349146e-01]\n",
      " [ 1.96553714e-01 -2.89890894e-03]\n",
      " [ 1.48762234e-01 -1.68010627e-01]\n",
      " [ 1.93731682e-01 -7.56945338e-03]\n",
      " [ 1.43406493e-02 -1.70606227e-01]\n",
      " [ 5.09155360e-02 -1.54521043e-01]\n",
      " [ 1.95645745e-01 -2.15792650e-01]\n",
      " [ 1.60826495e-01 -1.28683967e-02]\n",
      " [ 5.10381613e-02 -1.91220314e-01]\n",
      " [ 8.47373406e-02 -1.68722553e-01]\n",
      " [ 1.48830076e-01 -8.12456064e-02]\n",
      " [ 2.98403675e-02 -1.43914362e-01]\n",
      " [ 5.00363230e-02 -1.42807979e-01]\n",
      " [ 1.13884353e-01 -1.87362497e-03]\n",
      " [ 3.91776762e-01 -2.85213004e-02]\n",
      " [ 2.30513941e-01 -2.05903663e-02]\n",
      " [ 1.00541993e-01 -5.52223813e-03]\n",
      " [ 9.02221007e-02 -2.02361404e-02]\n",
      " [ 1.21153567e-01 -1.99321805e-03]\n",
      " [ 6.10868073e-02 -1.46734788e-01]\n",
      " [ 3.06073816e-01 -2.45675598e-02]\n",
      " [ 3.20926285e-01 -1.20539529e-02]\n",
      " [ 3.97489639e-02 -1.74864272e-02]\n",
      " [ 3.95148740e-02 -9.33774116e-02]\n",
      " [ 1.87946773e-02 -1.07303009e-01]\n",
      " [ 1.25746225e-01 -2.61155501e-01]\n",
      " [ 3.42783997e-01 -5.05560902e-03]\n",
      " [ 9.34242255e-02 -1.05512258e-01]\n",
      " [ 1.21665830e-01 -4.75370792e-03]\n",
      " [ 5.11908276e-04 -1.82129965e-03]\n",
      " [ 2.90311249e-02 -1.84655147e-01]\n",
      " [ 4.40852294e-04 -3.54954669e-04]\n",
      " [ 3.66433882e-02 -3.08484723e-01]\n",
      " [ 1.31996331e-01 -1.24503634e-01]\n",
      " [ 1.69645836e-01 -1.82332364e-02]\n",
      " [ 1.20904628e-01 -1.63754963e-02]\n",
      " [ 9.30705537e-04 -1.53618355e-01]\n",
      " [ 1.60658725e-02 -4.96527497e-02]\n",
      " [ 5.12758473e-02 -5.25812120e-02]\n",
      " [ 7.61285193e-02 -2.00743337e-02]\n",
      " [ 2.42211459e-01 -2.67494381e-02]\n",
      " [ 1.08037056e-01 -7.29935806e-03]\n",
      " [ 5.56696698e-02 -7.59219207e-02]\n",
      " [ 6.81698015e-02 -9.31753695e-03]\n",
      " [ 7.76377866e-03 -5.87048859e-02]\n",
      " [ 8.83934279e-03 -6.78909187e-02]\n",
      " [ 7.32514072e-02 -2.59545131e-02]\n",
      " [ 5.98250712e-02 -1.83512947e-01]\n",
      " [ 6.23443281e-02 -1.50515089e-01]\n",
      " [ 2.83717819e-01 -4.02167896e-02]\n",
      " [ 4.54255553e-02 -7.07322916e-02]\n",
      " [ 6.30366782e-02 -6.79508527e-02]\n",
      " [ 1.33411639e-01 -1.48162493e-02]\n",
      " [ 3.99371874e-04 -8.29991302e-04]\n",
      " [ 2.21977525e-01 -1.97552934e-01]\n",
      " [ 6.32869543e-04 -2.20769461e-04]\n",
      " [ 1.70564574e-02 -1.79636348e-01]\n",
      " [ 7.00543195e-02 -4.80385625e-01]\n",
      " [ 3.27847358e-03 -1.95440526e-01]\n",
      " [ 1.36336348e-01 -4.04496218e-02]\n",
      " [ 3.57076092e-03 -6.84170541e-02]\n",
      " [ 7.53327644e-03 -1.27709215e-01]\n",
      " [ 1.38620804e-01 -4.07631036e-02]\n",
      " [ 5.30392455e-02 -1.89084935e-01]\n",
      " [ 1.18089292e-01 -1.03248786e-01]\n",
      " [ 2.02742329e-02 -2.04523627e-01]\n",
      " [ 3.19994160e-01 -1.31160530e-01]\n",
      " [ 1.85204943e-01 -2.87982307e-01]\n",
      " [ 4.43699907e-01 -2.90508345e-01]\n",
      " [ 3.62621139e-02 -9.25667814e-02]\n",
      " [ 3.83083523e-02 -6.30258879e-02]\n",
      " [ 3.83760947e-02 -6.29173163e-02]\n",
      " [ 3.62621139e-02 -9.25667814e-02]\n",
      " [ 9.00852009e-02 -2.79901491e-01]\n",
      " [ 1.55105664e-04 -2.49517666e-04]\n",
      " [ 1.96180023e-02 -1.76733768e-01]\n",
      " [ 4.40443148e-02 -3.17940776e-02]\n",
      " [ 7.83007344e-02 -4.29831163e-02]\n",
      " [ 1.94759862e-03 -1.89373517e-04]\n",
      " [ 9.34984265e-03 -6.83630625e-02]\n",
      " [ 1.52197781e-02 -1.36101599e-01]\n",
      " [ 2.45401901e-02 -9.49107989e-03]\n",
      " [ 5.59553731e-02 -4.49577871e-04]\n",
      " [ 8.60472233e-02 -4.49869550e-02]\n",
      " [ 8.59950875e-02 -4.52136300e-02]\n",
      " [ 1.55272576e-02 -1.36018708e-01]\n",
      " [ 3.48249753e-02 -6.13231349e-02]\n",
      " [ 2.59306444e-02 -4.36222838e-02]\n",
      " [ 1.66164177e-02 -5.31389249e-02]\n",
      " [ 1.04181163e-01 -3.99709088e-02]\n",
      " [ 5.38489980e-02 -2.94383906e-02]\n",
      " [ 1.10776118e-02 -3.54259499e-02]\n",
      " [ 3.40064681e-06 -5.88447684e-06]\n",
      " [ 4.64185949e-02 -8.37577157e-02]\n",
      " [ 6.94708239e-02 -8.28400460e-03]\n",
      " [ 7.85859081e-02 -5.34636451e-02]\n",
      " [ 1.00669226e-01 -2.32095288e-02]\n",
      " [ 3.10407696e-02 -5.51244442e-02]\n",
      " [ 1.36896387e-01 -1.00325107e-01]\n",
      " [ 1.36896387e-01 -1.00325107e-01]\n",
      " [ 6.68017544e-02 -7.22870154e-02]\n",
      " [ 1.49875152e-02 -5.66626573e-02]\n",
      " [ 2.88099333e-02 -4.23203914e-02]\n",
      " [ 3.55194488e-03 -1.39912307e-01]\n",
      " [ 5.87439965e-02 -3.42273977e-02]\n",
      " [ 4.71805472e-02 -8.58296313e-02]\n",
      " [ 1.63985600e-02 -4.93597226e-02]\n",
      " [ 5.11362881e-02 -3.79402598e-03]\n",
      " [ 1.69850404e-01 -5.15211970e-02]\n",
      " [ 4.32499197e-02 -1.73796374e-01]\n",
      " [ 2.53043240e-02 -6.30996636e-02]\n",
      " [ 1.47711190e-01 -1.83469213e-01]\n",
      " [ 6.44458420e-02 -2.09468346e-02]\n",
      " [ 4.60631809e-02 -8.68098215e-02]\n",
      " [ 5.31219116e-02 -2.38566271e-01]\n",
      " [ 1.60636590e-02 -5.78544612e-01]\n",
      " [ 2.82619892e-01 -3.91685976e-01]\n",
      " [ 2.79499072e-01 -5.22943938e-01]\n",
      " [ 1.01879605e-01 -1.66189238e-01]\n",
      " [ 6.46620824e-02 -9.83132114e-02]\n",
      " [ 1.06052655e-01 -4.16782145e-01]\n",
      " [ 7.34520771e-02 -2.96850914e-01]\n",
      " [ 1.45863293e-01 -1.87005706e-01]\n",
      " [ 1.44342117e-01 -1.90634841e-01]\n",
      " [ 2.17997204e-01 -1.36018408e-01]\n",
      " [ 1.59394949e-01 -1.71807019e-01]\n",
      " [ 1.80001926e-01 -2.42867633e-01]\n",
      " [ 2.72228330e-01 -3.38540826e-01]\n",
      " [ 3.36808274e-02 -2.77313785e-01]\n",
      " [ 1.49330275e-01 -9.94351728e-02]\n",
      " [ 5.15537690e-02 -4.24472078e-01]\n",
      " [ 1.84134912e-01 -1.68510469e-01]\n",
      " [ 3.92842601e-02 -3.89904321e-02]\n",
      " [ 2.53667984e-02 -6.29942496e-02]\n",
      " [ 3.13689013e-01 -2.63520619e-01]\n",
      " [ 3.13096638e-01 -2.65358826e-01]\n",
      " [ 2.46480220e-04 -1.82936124e-03]\n",
      " [ 1.86584817e-01 -4.48788948e-01]\n",
      " [ 1.85727636e-01 -4.49981512e-01]\n",
      " [ 2.81268076e-02 -9.73171502e-02]\n",
      " [ 4.59206536e-02 -1.80436185e-01]\n",
      " [ 3.58349881e-01 -5.55298769e-02]\n",
      " [ 1.23014273e-03 -4.64584990e-04]\n",
      " [ 3.46314453e-01 -4.19086722e-02]\n",
      " [ 1.82750533e-01 -3.30375400e-01]\n",
      " [ 2.69383729e-01 -1.54236365e-01]\n",
      " [ 4.74592576e-01 -4.89307411e-01]\n",
      " [ 3.18699673e-03 -2.01817070e-01]\n",
      " [ 6.82360689e-02 -2.10599586e-01]\n",
      " [ 2.67476546e-02 -4.32909890e-01]\n",
      " [ 1.44708409e-02 -3.06438198e-01]\n",
      " [ 7.25522408e-04 -1.40191075e-03]\n",
      " [ 1.30633652e-02 -1.25863386e-01]\n",
      " [ 9.29534896e-02 -1.02428737e-02]\n",
      " [ 1.14318234e-03 -9.83513443e-02]\n",
      " [ 6.49315496e-02 -1.66148945e-02]\n",
      " [ 9.52202272e-02 -2.52548644e-04]\n",
      " [ 8.32626159e-02 -6.70374790e-03]\n",
      " [ 4.14939315e-02 -6.95841632e-02]\n",
      " [ 1.89120222e-01 -9.01954793e-02]\n",
      " [ 1.38219013e-01 -3.72226377e-02]\n",
      " [ 1.20804919e-01 -1.08581094e-01]\n",
      " [ 7.42024961e-03 -1.05167803e-02]\n",
      " [ 4.59675792e-18 -1.16059372e-01]\n",
      " [ 4.11088914e-02 -2.82662991e-02]\n",
      " [ 1.45360226e-02 -5.22222965e-01]\n",
      " [ 3.72355100e-03 -4.07441138e-01]\n",
      " [ 1.98740035e-02 -2.97456020e-01]\n",
      " [ 1.65580421e-02 -1.09468566e-02]\n",
      " [ 1.97420315e-01 -1.73901536e-01]\n",
      " [ 3.01818821e-01 -3.40410707e-01]\n",
      " [ 9.86399416e-02 -3.85197519e-01]\n",
      " [ 6.36892147e-01 -3.81038713e-02]\n",
      " [ 2.08553910e-02 -1.31858073e-01]\n",
      " [ 1.43848931e-01 -1.24670283e-01]\n",
      " [ 9.50859697e-02 -1.99190252e-01]\n",
      " [ 9.46096823e-02 -1.97457180e-01]\n",
      " [ 1.50207381e-01 -9.31245675e-02]\n",
      " [ 1.49775292e-01 -1.29806512e-01]\n",
      " [ 1.72413527e-01 -2.01711912e-02]\n",
      " [ 2.55820095e-02 -4.29109877e-02]\n",
      " [ 1.58513882e-01 -1.54721251e-01]\n",
      " [ 2.90935762e-01 -2.00511715e+00]\n",
      " [ 3.47603710e+00  0.00000000e+00]]\n"
     ]
    }
   ],
   "source": [
    "E_kabels=np.zeros((len(kabels),2))                \n",
    "E_kabels=calcE(kabels,EX_matrix,EY_matrix,lat,lon,1300)\n",
    "print(E_kabels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(array([ 6.64807950e-01, -2.28432112e-01,  2.26505246e-01, -3.36336218e-01,\n",
      "       -4.09090009e-03,  1.67054919e-02, -4.01226829e-02,  2.09462860e-02,\n",
      "        1.26084631e-02, -7.33703230e-03, -1.48097120e-02,  1.32798628e-02,\n",
      "        2.78243519e-02, -8.58216400e-02, -2.06924192e-02,  5.44205351e-02,\n",
      "       -8.08290429e-02,  6.28667603e-02,  6.05333152e-03,  1.72423421e-02,\n",
      "        3.62372888e-03, -3.19700015e-03, -1.40500879e-02,  1.19398425e-02,\n",
      "        1.06403497e-04,  1.31673838e-03, -2.04997910e-03,  5.75134529e-03,\n",
      "       -4.70901703e-02,  1.30814430e-02, -2.72012212e-02,  1.31502155e-01,\n",
      "        8.57156762e-02,  1.35005299e-01,  4.96681920e-02,  4.19791203e-02,\n",
      "       -2.61268965e-02,  1.59340814e-01,  1.58829415e-03,  1.41339481e-01,\n",
      "        2.40139163e-01, -2.54817492e-01,  4.57225782e-02, -9.22988568e-03,\n",
      "        1.91198274e-02,  1.42482557e-03, -4.56265583e-02, -2.10574434e-02,\n",
      "       -1.72963149e-02,  4.23533614e-02,  7.37569296e-02,  3.10551496e-02,\n",
      "        2.35540068e-02, -1.74541391e-01,  2.83471958e-01,  1.02210473e-01,\n",
      "       -2.72408869e-01,  9.12474878e-03,  1.46237494e-01, -1.50247229e-02,\n",
      "        5.01910004e-03, -2.09571137e-01, -1.32638681e-01,  2.18538901e-02,\n",
      "       -1.46121894e-02, -5.67945530e-02,  7.23181391e-02,  2.38299719e-02,\n",
      "        2.20798109e-03, -3.27282923e-02,  5.03313877e-02, -1.75765138e-01,\n",
      "       -2.75324179e-01,  7.66593866e-02,  2.23478457e-01, -5.63342628e-03,\n",
      "       -4.81169125e-03,  3.60252076e-02, -2.50207134e-01, -5.60558672e-02,\n",
      "       -1.16177097e-02, -1.35723989e-02, -1.95625039e-01, -1.57948871e-01,\n",
      "        1.64503685e-01,  7.94022819e-02, -1.19452921e-01, -1.77472632e-02,\n",
      "       -5.01304446e-02, -4.67159079e-04, -6.34521208e-02, -3.27639687e-03,\n",
      "       -1.14946547e-01,  5.25029578e-02, -1.39106289e-01,  1.12374105e-01,\n",
      "        8.61531715e-02, -9.04135861e-02,  3.75071393e-02, -4.08440145e-02,\n",
      "       -2.35459087e-02,  2.92617494e-02,  1.69348484e-01,  1.55656380e-01,\n",
      "        1.17196816e-01, -1.36338705e-01, -1.56605931e-01, -1.24432802e-02,\n",
      "       -1.81342599e-02, -3.00989835e-02, -1.03630467e-02, -4.79102048e-02,\n",
      "       -1.87946351e-02, -2.38102615e-02, -2.67146719e-02, -2.29278360e-02,\n",
      "        6.57621732e-02, -1.02518578e-01, -4.43231337e-02, -3.41303472e-03,\n",
      "       -2.39671065e-02, -4.47859884e-04, -1.70038330e-02,  5.34485652e-03,\n",
      "       -1.10558506e-02,  8.38277539e-03,  4.12999061e-03,  1.26448615e-03,\n",
      "        1.06149073e-02, -3.02405468e-02,  1.71915741e-02, -1.73999873e-02,\n",
      "       -7.43210752e-02,  8.85156576e-02,  5.87504664e-03,  9.68432169e-03,\n",
      "       -2.98283585e-02,  1.51442478e-02, -3.72792179e-02, -2.44263469e-03,\n",
      "        1.48706331e-02, -1.57028686e-02,  1.09272460e-02, -2.13742294e-02,\n",
      "        6.98036951e-03,  8.11286485e-04,  1.37835794e-02,  1.15278168e-01,\n",
      "        1.06357602e-01]), array([ 1.97538799e-01, -4.58003303e-01,  4.19732350e-01, -1.34854677e-01,\n",
      "       -1.28414431e+00, -5.20185973e-01, -2.78240889e-01,  9.22377368e-01,\n",
      "       -1.60939393e+00,  2.86913714e-01,  4.26724311e-01, -1.67332511e+00,\n",
      "        2.41355389e+00, -1.94328337e+00,  8.10671857e-01,  4.71472758e-01,\n",
      "       -5.16866335e+00, -4.25949641e-01,  4.71452805e+00, -4.43734016e-01,\n",
      "       -1.33414335e+00,  3.37360575e-01,  1.19953948e-01, -1.17714834e-02,\n",
      "        6.40755165e-01,  2.92547178e-01, -1.22262784e-02, -1.84772234e+00,\n",
      "        2.93004638e+00,  9.27678741e-01, -2.49485201e-01,  8.37028153e-01,\n",
      "       -1.76865829e+00, -6.80879979e-01, -6.48788561e-01, -3.08062609e-01,\n",
      "        8.07944105e-01, -1.00221460e+00, -1.82247274e-02, -4.66787882e-01,\n",
      "       -1.30425642e-01,  1.90244975e+00,  3.41387039e-01, -3.30496853e-01,\n",
      "        5.84905601e-01, -7.26268786e-02,  5.76427197e-01,  2.79206001e-01,\n",
      "        4.37055790e-01, -1.42435047e-01, -9.37870610e-01, -1.73036831e-01,\n",
      "        9.02856672e-01,  6.04318501e-01,  5.84512215e-01, -1.27214942e+00,\n",
      "       -9.82924134e-02, -3.57252620e-01, -5.14980293e-01,  1.82354754e+00,\n",
      "        1.21799225e+00, -6.11220569e-01,  8.23651691e-01, -1.48864473e+00,\n",
      "        8.58389344e-01,  5.04387574e-01,  5.89068315e-01,  1.64488662e-01,\n",
      "       -5.42334855e-01, -3.43580534e-01,  1.96857585e-01, -2.88064252e-01,\n",
      "        2.02790220e+00,  7.69392087e-01, -1.45627918e-01,  1.12167914e-01,\n",
      "       -5.44618069e-01,  2.22859765e+00,  1.00176438e-01, -1.72241055e+00,\n",
      "       -3.70034376e-01, -2.28348217e-01,  6.76167836e-01, -3.84564760e-01,\n",
      "        1.07085357e+00, -6.71143328e-01, -8.40787603e-01,  4.53660873e-01,\n",
      "        7.78517667e-01, -1.69961361e+00,  6.01956173e-01, -1.14936996e-01,\n",
      "        8.64795017e-01, -2.26570087e+00,  9.72874773e-01, -2.40432746e+00,\n",
      "        4.36508099e-02,  3.87796522e-01,  5.80436512e-01,  1.48547029e-01,\n",
      "       -6.05928056e-01,  1.62675410e+00,  5.89300799e-02, -5.89139807e-02,\n",
      "       -4.12204278e-01,  1.45048984e+00,  1.02425914e+00, -7.15997131e-02,\n",
      "       -1.41504129e+00,  7.10596943e-01,  7.01344560e-01, -2.39573158e+00,\n",
      "        1.61286307e+00,  1.68041934e+00, -8.55864320e-01, -8.73248393e-01,\n",
      "        8.33709764e-01, -4.73700026e-01, -1.58108747e+00,  4.61094234e-01,\n",
      "        9.19050957e-01,  2.30026590e+00, -2.25991527e+00, -1.23485155e+00,\n",
      "        3.07633063e-01, -3.09737085e-01, -8.64777708e-01,  7.85396246e-01,\n",
      "       -7.91500573e-02,  1.16946084e-01, -4.75886403e-01,  3.73131233e-01,\n",
      "        5.05633685e-01, -1.16722392e+00,  7.02912764e-01,  1.38965210e+00,\n",
      "       -2.69612492e-02,  1.76586781e-01, -5.48491257e-01, -4.09180963e-03,\n",
      "       -2.99464677e-01,  2.93895035e-01, -9.72780518e-02, -9.99302397e-01,\n",
      "       -7.38935566e-01,  5.00449015e-01, -5.14982099e-01,  0.00000000e+00,\n",
      "       -9.49198701e-01]))\n"
     ]
    }
   ],
   "source": [
    "J_kabels=np.zeros((len(kabels),2)) \n",
    "J_kabels=ObtainJ(kabels,EX_matrix,EY_matrix,lat,lon,0,trafo_connect)\n",
    "print(J_kabels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0 has no problems\n",
      "1.0 has no problems\n",
      "2.0 has no problems\n",
      "3.0 has no problems\n",
      "4.0 has no problems\n",
      "5.0 has no problems\n",
      "6.0 has no problems\n",
      "7.0 has no problems\n",
      "8.0 has no problems\n",
      "9.0 has no problems\n",
      "10.0 has no problems\n",
      "11.0 has no problems\n",
      "12.0 has no problems\n",
      "13.0 has no problems\n",
      "14.0 has no problems\n",
      "15.0 has no problems\n",
      "16.0 has no problems\n",
      "17.0 has no problems\n",
      "18.0 has no problems\n",
      "19.0 has no problems\n",
      "20.0 has no problems\n",
      "21.0 has no problems\n",
      "22.0 has no problems\n",
      "23.0 has no problems\n",
      "24.0 has no problems\n",
      "25.0 has no problems\n",
      "26.0 has no problems\n",
      "27.0 has no problems\n",
      "28.0 has no problems\n",
      "29.0 has no problems\n",
      "30.0 has no problems\n",
      "31.0 has no problems\n",
      "32.0 has no problems\n",
      "33.0 has no problems\n",
      "34.0 has no problems\n",
      "35.0 has no problems\n",
      "36.0 has no problems\n",
      "Hey, station 37.0 is incorrect, has now 10.0 cables, but should be 11.0!\n",
      "38.0 has no problems\n",
      "39.0 has no problems\n",
      "40.0 has no problems\n",
      "41.0 has no problems\n",
      "42.0 has no problems\n",
      "43.0 has no problems\n",
      "44.0 has no problems\n",
      "45.0 has no problems\n",
      "46.0 has no problems\n",
      "47.0 has no problems\n",
      "48.0 has no problems\n",
      "49.0 has no problems\n",
      "50.0 has no problems\n",
      "51.0 has no problems\n",
      "52.0 has no problems\n",
      "53.0 has no problems\n",
      "54.0 has no problems\n",
      "55.0 has no problems\n",
      "56.0 has no problems\n",
      "57.0 has no problems\n",
      "58.0 has no problems\n",
      "59.0 has no problems\n",
      "60.0 has no problems\n",
      "61.0 has no problems\n",
      "62.0 has no problems\n",
      "63.0 has no problems\n",
      "64.0 has no problems\n",
      "65.0 has no problems\n",
      "66.0 has no problems\n",
      "67.0 has no problems\n",
      "68.0 has no problems\n",
      "69.0 has no problems\n",
      "70.0 has no problems\n",
      "71.0 has no problems\n",
      "72.0 has no problems\n",
      "73.0 has no problems\n",
      "74.0 has no problems\n",
      "75.0 has no problems\n",
      "76.0 has no problems\n",
      "77.0 has no problems\n",
      "78.0 has no problems\n",
      "79.0 has no problems\n",
      "80.0 has no problems\n",
      "81.0 has no problems\n",
      "82.0 has no problems\n",
      "83.0 has no problems\n",
      "84.0 has no problems\n",
      "85.0 has no problems\n",
      "86.0 has no problems\n",
      "87.0 has no problems\n",
      "88.0 has no problems\n",
      "89.0 has no problems\n",
      "90.0 has no problems\n",
      "91.0 has no problems\n",
      "92.0 has no problems\n",
      "93.0 has no problems\n",
      "94.0 has no problems\n",
      "95.0 has no problems\n",
      "96.0 has no problems\n",
      "97.0 has no problems\n",
      "98.0 has no problems\n",
      "99.0 has no problems\n",
      "100.0 has no problems\n",
      "101.0 has no problems\n",
      "102.0 has no problems\n",
      "103.0 has no problems\n",
      "104.0 has no problems\n",
      "105.0 has no problems\n",
      "106.0 has no problems\n",
      "107.0 has no problems\n",
      "108.0 has no problems\n",
      "109.0 has no problems\n",
      "110.0 has no problems\n",
      "111.0 has no problems\n",
      "112.0 has no problems\n",
      "113.0 has no problems\n",
      "114.0 has no problems\n",
      "115.0 has no problems\n",
      "116.0 has no problems\n",
      "117.0 has no problems\n",
      "118.0 has no problems\n",
      "119.0 has no problems\n",
      "120.0 has no problems\n",
      "121.0 has no problems\n",
      "122.0 has no problems\n",
      "123.0 has no problems\n",
      "124.0 has no problems\n",
      "125.0 has no problems\n",
      "126.0 has no problems\n",
      "127.0 has no problems\n",
      "128.0 has no problems\n",
      "129.0 has no problems\n",
      "130.0 has no problems\n",
      "131.0 has no problems\n",
      "132.0 has no problems\n",
      "133.0 has no problems\n",
      "134.0 has no problems\n",
      "135.0 has no problems\n",
      "136.0 has no problems\n",
      "137.0 has no problems\n",
      "138.0 has no problems\n",
      "139.0 has no problems\n",
      "140.0 has no problems\n",
      "141.0 has no problems\n",
      "142.0 has no problems\n",
      "143.0 has no problems\n",
      "144.0 has no problems\n",
      "145.0 has no problems\n",
      "146.0 has no problems\n",
      "147.0 has no problems\n",
      "148.0 has no problems\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "station=np.zeros(149)\n",
    "cable=np.zeros(149)\n",
    "ob_cable=np.zeros(149)\n",
    "path='/usr/people/out/Documents'\n",
    "f=open(f'{path}/original')\n",
    "g=open(f'{path}/obtained_cable')\n",
    "for counter,item in enumerate(f):\n",
    "    item=item.split(' ')\n",
    "    station[counter]=item[0]\n",
    "    cable[counter]=item[1]\n",
    "for counter,item in enumerate(g):\n",
    "    item=item.split(' ')\n",
    "    ob_cable[counter]=item[1]\n",
    "    \n",
    "for counter in range(149):\n",
    "    if cable[counter]-ob_cable[counter] != 0:\n",
    "        print(f'Hey, station {station[counter]} is incorrect, has now {ob_cable[counter]} cables, but should be {cable[counter]}!')\n",
    "    else:\n",
    "        print(f'{station[counter]} has no problems')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Directory has already been created, data could be destroyed!\n",
      "New data is added now!\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Process Process-1:\n",
      "Traceback (most recent call last):\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 297, in _bootstrap\n",
      "    self.run()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 99, in run\n",
      "    self._target(*self._args, **self._kwargs)\n",
      "  File \"<ipython-input-3-dd29b58c94ae>\", line 32, in GICfunction\n",
      "    localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/GIC_{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py\", line 3228, in to_csv\n",
      "    formatter.save()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/io/formats/csvs.py\", line 220, in save\n",
      "    f.close()\n",
      "OSError: [Errno 5] Input/output error\n",
      "Process Process-2:\n",
      "Traceback (most recent call last):\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 297, in _bootstrap\n",
      "    self.run()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 99, in run\n",
      "    self._target(*self._args, **self._kwargs)\n",
      "  File \"<ipython-input-3-dd29b58c94ae>\", line 32, in GICfunction\n",
      "    localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/GIC_{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py\", line 3228, in to_csv\n",
      "    formatter.save()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/io/formats/csvs.py\", line 220, in save\n",
      "    f.close()\n",
      "OSError: [Errno 5] Input/output error\n",
      "Process Process-4:\n",
      "Traceback (most recent call last):\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 297, in _bootstrap\n",
      "    self.run()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 99, in run\n",
      "    self._target(*self._args, **self._kwargs)\n",
      "  File \"<ipython-input-3-dd29b58c94ae>\", line 32, in GICfunction\n",
      "    localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/GIC_{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py\", line 3228, in to_csv\n",
      "    formatter.save()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/io/formats/csvs.py\", line 220, in save\n",
      "    f.close()\n",
      "OSError: [Errno 5] Input/output error\n",
      "Process Process-6:\n",
      "Traceback (most recent call last):\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 297, in _bootstrap\n",
      "    self.run()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 99, in run\n",
      "    self._target(*self._args, **self._kwargs)\n",
      "  File \"<ipython-input-3-dd29b58c94ae>\", line 32, in GICfunction\n",
      "    localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/GIC_{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py\", line 3228, in to_csv\n",
      "    formatter.save()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/io/formats/csvs.py\", line 220, in save\n",
      "    f.close()\n",
      "OSError: [Errno 5] Input/output error\n",
      "Process Process-5:\n",
      "Traceback (most recent call last):\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 297, in _bootstrap\n",
      "    self.run()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 99, in run\n",
      "    self._target(*self._args, **self._kwargs)\n",
      "  File \"<ipython-input-3-dd29b58c94ae>\", line 32, in GICfunction\n",
      "    localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/GIC_{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py\", line 3228, in to_csv\n",
      "    formatter.save()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/io/formats/csvs.py\", line 220, in save\n",
      "    f.close()\n",
      "OSError: [Errno 5] Input/output error\n",
      "Process Process-3:\n",
      "Traceback (most recent call last):\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 297, in _bootstrap\n",
      "    self.run()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/multiprocessing/process.py\", line 99, in run\n",
      "    self._target(*self._args, **self._kwargs)\n",
      "  File \"<ipython-input-3-dd29b58c94ae>\", line 32, in GICfunction\n",
      "    localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/GIC_{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/core/generic.py\", line 3228, in to_csv\n",
      "    formatter.save()\n",
      "  File \"/usr/people/out/anaconda3/lib/python3.7/site-packages/pandas/io/formats/csvs.py\", line 220, in save\n",
      "    f.close()\n",
      "OSError: [Errno 5] Input/output error\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Script has been completed!\n"
     ]
    }
   ],
   "source": [
    "# obtain real voltages per cable piece and execute total code\n",
    "import os\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import math\n",
    "import logging\n",
    "from scipy.interpolate import griddata\n",
    "from threading import local\n",
    "localvar=local()\n",
    "from multiprocessing import Process\n",
    "from multiprocessing import Lock\n",
    "lock=Lock()\n",
    "path='/usr/people/out/Documents/Magnetic_field/station_results/Halloween'\n",
    "plotday='Halloween storm'\n",
    "logging.basicConfig(filename=f'{path}/GIClogbook.log', level=logging.DEBUG, format='%(asctime)s %(message)s')\n",
    "#################################### first reading in datasets #####################################################\n",
    "try:\n",
    "    os.mkdir(f'{path}/GIC')\n",
    "except:\n",
    "    logging.warning(\"Directory has already been created, data could be destroyed!\")\n",
    "    print(\"Directory has already been created, data could be destroyed!\")\n",
    "logging.info('Reading in datasets!')\n",
    "Electric_Xfiles=[]\n",
    "Electric_Yfiles=[]\n",
    "os.system(f' ls {path}/electric_field_north/*.csv > {path}/temp.txt')\n",
    "f=open(f'{path}/temp.txt')\n",
    "for item in f:\n",
    "    item=item.strip('\\n')\n",
    "    Electric_Xfiles.append(item)\n",
    "f.close()\n",
    "os.system(f' ls {path}/electric_field_east/*.csv > {path}/temp.txt')\n",
    "f=open(f'{path}/temp.txt')\n",
    "for item in f:\n",
    "    item=item.strip('\\n')\n",
    "    Electric_Yfiles.append(item)\n",
    "f.close()\n",
    "os.system(f'rm {path}/temp.txt')\n",
    "logging.debug('Electric files created!')\n",
    "\n",
    "for counter,file in enumerate(Electric_Xfiles):\n",
    "    Xfile=pd.read_csv(file, delimiter=' ', header=None)\n",
    "    values=Xfile.to_numpy()\n",
    "    break\n",
    "EX_matrix=np.zeros((len(Electric_Xfiles),len(values)))    \n",
    "EY_matrix=np.zeros((len(Electric_Xfiles),len(values)))\n",
    "logging.debug('Electric matrices have been made in memory!')\n",
    "\n",
    "for counter,file in enumerate(Electric_Xfiles):\n",
    "    Xfile=pd.read_csv(file, delimiter=' ', header=None)\n",
    "    values=Xfile.to_numpy()\n",
    "    EX_matrix[counter,:]=values[:,2]\n",
    "logging.debug('EX_matrix has been made!')\n",
    "lat=values[:,1]\n",
    "lon=values[:,0]\n",
    "for counter,file in enumerate(Electric_Yfiles):\n",
    "    Yfile=pd.read_csv(file, delimiter=' ', header=None)\n",
    "    values=Yfile.to_numpy()\n",
    "    EY_matrix[counter,:]=values[:,2]\n",
    "del item, f, Xfile, values, Yfile\n",
    "\n",
    "######################################### Getting the needed GIC matrices and code #################################\n",
    "logging.info('Starting with the GIC code!')\n",
    "path2='/usr/people/out/Documents/380+220kV_extended'\n",
    "kabels=pd.read_csv(path2+'/spreadsheetcables.csv', delimiter = ';')\n",
    "trafo=pd.read_csv(path2+'/spreadsheettrafo.csv', delimiter = ';')\n",
    "trafo_connect=np.zeros((len(trafo),len(trafo))) #connectivity trafo\n",
    "trafo_all_connections=np.zeros((len(trafo),len(kabels))) #connections possible between trafo and every cable\n",
    "trafo_cond=np.zeros((len(trafo),len(trafo))) # The conductivity matrix\n",
    "stat_heading=np.zeros((len(trafo),len(trafo))) #heading stations to another\n",
    "stat_length=np.zeros((len(trafo),len(trafo))) #length between stations\n",
    "station_lat=np.zeros(len(trafo)) #latitude stations in degrees\n",
    "station_lon=np.zeros(len(trafo)) #longitude stations in degrees\n",
    "ground_cond=np.zeros(len(trafo))\n",
    "cable_icon=np.zeros(len(kabels)) # icon array for cable and trafo resp.\n",
    "trafo_icon=np.zeros(len(trafo))\n",
    "\n",
    "##### connect trafo and cable number to position in matrix #####\n",
    "for line in range(len(kabels)):\n",
    "    cable_icon[line]=kabels.at[line,'kabelnr']\n",
    "for line in range(len(trafo)):\n",
    "    trafo_icon[line]=trafo.at[line,'trafonr']\n",
    "##### make trafo-trafo connectivity matrix ######\n",
    "for line in range(len(trafo)): \n",
    "    temp=trafo.at[line,'verbonden trafo'] #get right column\n",
    "    temp=temp.split(\",\") #split values\n",
    "    \n",
    "    for item in temp:\n",
    "        temp2=int(item)\n",
    "        trafo_connect[line,np.where(trafo_icon == temp2)[0]]=True #check for connection other trafo\n",
    "        del temp2\n",
    "    del temp\n",
    "###### make trafo-cable connectivity matrix ######\n",
    "for line in range(len(trafo)):\n",
    "    temp=trafo.at[line,'alle aansluitingen']\n",
    "    temp=temp.split(\",\")\n",
    "    for item in temp:\n",
    "        temp2=int(item)\n",
    "        trafo_all_connections[line,np.where(cable_icon == temp2)[0]]=True\n",
    "        del temp2\n",
    "    del temp\n",
    "###### make conductivity matrix ######\n",
    "for row,line in enumerate(trafo_connect):\n",
    "    trafo_cond[row,row]=trafo.at[row,'conductivity total']\n",
    "    for column,item in enumerate(line):\n",
    "        if item:\n",
    "            temp=trafo_all_connections[row,:]+trafo_all_connections[column,:]\n",
    "            temp2=0\n",
    "            for counter,value in enumerate(temp):\n",
    "                if value == 2: # if 2 then we have found the connecting cables\n",
    "                    temp2+=1/(float(kabels.at[counter,'conductivity'])*kabels.at[counter,'kab/3'])  #because of serieschain we have to add 1/sigma\n",
    "#             if temp2==0:\n",
    "#                 print(row,column)\n",
    "            trafo_cond[row,column]=-1/temp2 #add cable resistance to off-diagonal\n",
    "            trafo_cond[row,row]+=1/temp2 #add cable resistance to trace\n",
    "            del temp, temp2\n",
    "###### get heading and length between stations #####\n",
    "for row,line in enumerate(trafo_connect):\n",
    "    for column,item in enumerate(line):\n",
    "        if item and column>=row:\n",
    "            Alat=np.radians(trafo.at[row,'lat'])\n",
    "            Alon=np.radians(trafo.at[row,'lon'])\n",
    "            Blat=np.radians(trafo.at[column,'lat'])\n",
    "            Blon=np.radians(trafo.at[column,'lon'])\n",
    "            temp=math.cos(Blat)*math.sin(Blon-Alon)\n",
    "            temp2=math.cos(Alat)*math.sin(Blat)-math.sin(Alat)*math.cos(Blat)*math.cos(Blon-Alon)\n",
    "            stat_heading[row,column]=np.abs(math.degrees(math.atan(temp/temp2)))\n",
    "            temp3=math.sin((Blat-Alat)/2.)**2+math.cos(Alat)*math.cos(Blat)*math.sin((Blon-Alon)/2.)**2\n",
    "            stat_length[row,column]=6371000*2*math.atan(np.sqrt(temp3)/np.sqrt(1-temp3))\n",
    "            stat_heading[column,row]=stat_heading[row,column]\n",
    "            stat_length[column,row]=stat_length[row,column]\n",
    "            del temp, temp2, temp3, Alat, Alon, Blat, Blon\n",
    "del line, item, row, column, value, counter\n",
    "######### get necessary arrays ########\n",
    "for item in range(len(trafo)):\n",
    "    station_lat[item]=trafo.at[item,'lat']\n",
    "    station_lon[item]=trafo.at[item,'lon']\n",
    "    ground_cond[item]=trafo.at[item,'conductivity total']\n",
    "\n",
    "############################### Run the function with multiple processors ##########################################\n",
    "logging.info('Start multiprocessing!')\n",
    "print(\"New data is added now!\")\n",
    "n=6\n",
    "nrsteps=int(1440*3/n)\n",
    "threads=list()\n",
    "for index in range(n):\n",
    "    q=Process(target=GICfunction, args=(index+1,nrsteps*index,nrsteps*(index+1),trafo,EX_matrix,EY_matrix,lat,lon,station_lat,station_lon,trafo_connect,stat_heading,stat_length,trafo_cond,ground_cond,path,path2,kabels,trafo_all_connections,plotday))\n",
    "    threads.append(q)\n",
    "    q.start()\n",
    "for thread in threads:\n",
    "    thread.join()\n",
    "logging.info(\"Script has been completed!\")\n",
    "print(\"Script has been completed!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def GICfunction(q,begin,end,trafo,EX_matrix,EY_matrix,lat,lon,station_lat,station_lon,trafo_connect,stat_heading,stat_length,trafo_cond,ground_cond,path,path2,kabels,trafo_all_connections,plotday):\n",
    "    \n",
    "######################################### interpolation ############################################################\n",
    "    localvar.volt_result=np.zeros(len(trafo))\n",
    "    localvar.J_total=np.zeros(len(trafo))\n",
    "    logging.info(f'Thread {q} has started interpolation!')\n",
    "    for localvar.time in range(begin,end):#range(len(grid_EX)):\n",
    "        localvar.J_north, localvar.J_east=ObtainJ(q,kabels,EX_matrix,EY_matrix,lat,lon,localvar.time,trafo_connect,trafo_all_connections,trafo_cond)\n",
    "        localvar.J_total=localvar.J_north+localvar.J_east\n",
    "        localvar.volt_result=np.linalg.solve(trafo_cond,localvar.J_total)\n",
    "        localvar.I_GIC=localvar.volt_result*ground_cond\n",
    "        \n",
    "##################################### getting max I_GIC and writing results ########################################\n",
    "        logging.info(f'Thread {q} is writing results to files for timestep {localvar.time}!')\n",
    "        localvar.maxAMP=1\n",
    "        if localvar.time<10:\n",
    "            localvar.tijd=f'000{localvar.time}'\n",
    "        elif localvar.time<100 and localvar.time>9:\n",
    "            localvar.tijd=f'00{localvar.time}'\n",
    "        elif localvar.time<1000 and localvar.time>99:\n",
    "            localvar.tijd=f'0{localvar.time}'\n",
    "        else:\n",
    "            localvar.tijd=f'{localvar.time}'\n",
    "        \n",
    "        ##### Save files #######\n",
    "        localvar.GIC=pd.DataFrame(columns=['lon','lat','GIC',f'GIC/{localvar.maxAMP}'])\n",
    "        GICmatrix=pd.DataFrame()\n",
    "        localvar.GIC.at[:,'lon']=station_lon\n",
    "        localvar.GIC.at[:,'lat']=station_lat\n",
    "        localvar.GIC.at[:,'GIC']=localvar.I_GIC\n",
    "        localvar.GIC.at[:,f'GIC/{localvar.maxAMP}']=localvar.I_GIC/localvar.maxAMP\n",
    "        localvar.GIC.to_csv(path_or_buf=f'{path}/GIC/GIC_{localvar.tijd}.csv', sep=';', index=False, header=True)\n",
    "        \n",
    "################################### Plotting results ###############################################################\n",
    "        lim1=3.3\n",
    "        lim2=7.5\n",
    "        lim3=50.5\n",
    "        lim4=54\n",
    "        legendlon=lim1+0.18\n",
    "        legendlat=lim4-0.1\n",
    "        textlon=legendlon+0.33\n",
    "        textlat=legendlat-0.01\n",
    "\n",
    "        with lock:\n",
    "            legend=open(f'{path2}/legend.txt','w+')\n",
    "            legend.write(f'{legendlon} {legendlat} 1 1')\n",
    "            legend.close()\n",
    "            legendtxt=open(f'{path2}/legendtext.txt', 'w+')\n",
    "            legendtxt.write(f'{textlon} {textlat} {localvar.maxAMP}A')\n",
    "            legendtxt.close()\n",
    "\n",
    "            ##### Use GMT to plot GICs ######\n",
    "            minute=localvar.time%60\n",
    "            hour=int(localvar.time/60)%24\n",
    "            DAY=int(localvar.time/(60*24))\n",
    "            if minute < 10:\n",
    "                minute=f'0{minute}'\n",
    "            if hour < 10:\n",
    "                hour=f'0{hour}'\n",
    "            \n",
    "            title=f'GIC at {plotday} - {DAY}:{hour}:{minute}'\n",
    "            proj='-JM15C -P'\n",
    "            lims=f'-R{lim1}/{lim2}/{lim3}/{lim4}'\n",
    "            psfile=f'{path}/GIC/GIC_at_{localvar.tijd}.ps' #aanpassen\n",
    "            pngfile=f'{path}/GIC/GIC_at_{localvar.tijd}.png' #aanpassen\n",
    "            os.system(f'gmt pscoast {proj} {lims} -W0.5p -K -Ggrey -Slightblue -Df -N1/0.25p> {psfile}' )\n",
    "            os.system(f'gmt psbasemap {proj} {lims} -Ba1g1 -BWeSn+t\"{title}\" -O -K>> {psfile}' )\n",
    "            os.system(f'gmt psxy {path2}/cables.csv {proj} {lims} -W0.5p -Wred -O -K>> {psfile}' )\n",
    "            os.system(f'gmt psxy {path}/GIC/GIC_{localvar.tijd}.csv {proj} {lims} -Ctopo.cpt -Scc -O -K>> {psfile}')    \n",
    "            os.system(f'gmt psxy {path2}/legend.txt {proj} {lims} -Ctopo.cpt -W -Scc -O -K>> {psfile}')\n",
    "            os.system(f'gmt pstext {path2}/legendtext.txt {proj} {lims} -F+f30pHelvetica,black -O>> {psfile}')\n",
    "        os.system(f'convert -density 300 {psfile} {pngfile}')\n",
    "        os.system(f'rm {psfile}')\n",
    "        logging.info(f'Thread {q} has fulfilled timestep {localvar.time}!')\n",
    "    logging.info(f'Thread {q} is finished!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def ObtainJ(q,kabels,EX_matrix,EY_matrix,lat,lon,time,trafo_connect,trafo_all_connections,trafo_cond):\n",
    "    localvar.cablecheck=np.zeros(len(kabels))\n",
    "    localvar.E_kabels=np.zeros((len(kabels),2))      \n",
    "    logging.info(f'Thread {q} has started integration procedure!')\n",
    "    localvar.E_kabels=calcE(kabels,EX_matrix,EY_matrix,lat,lon,time)\n",
    "    logging.info(f'Thread {q} has finished integration procedure and is now writing results!')\n",
    "    localvar.stat_voltN=np.zeros((len(trafo_connect),len(trafo_connect)))\n",
    "    localvar.stat_voltE=np.zeros((len(trafo_connect),len(trafo_connect)))\n",
    "    localvar.J_north=np.zeros(len(trafo_connect))\n",
    "    localvar.J_east=np.zeros(len(trafo_connect))\n",
    "    for localvar.row,localvar.line in enumerate(trafo_connect):\n",
    "        ruleA=999\n",
    "        for localvar.column,localvar.item in enumerate(localvar.line):\n",
    "            if localvar.item:\n",
    "                for localvar.number in range(len(kabels)):\n",
    "                    localvar.cablecheck[localvar.number]=trafo_all_connections[localvar.row,localvar.number]+trafo_all_connections[localvar.column,localvar.number]\n",
    "                localvar.A=np.array(np.where(localvar.cablecheck==2)) #find indices that indicate cables connected\n",
    "\n",
    "                localvar.coord=trafo.at[localvar.row,'lat']\n",
    "#                 print(localvar.row, localvar.column, localvar.coord, localvar.A, len(localvar.A[0]))\n",
    "                for localvar.counter2 in range(len(localvar.A[0])): #double loop to check the cable connections\n",
    "#                     NEWCOUNTER+=1\n",
    "#                     MEGACOUNTER+=1\n",
    "                    for localvar.counter in range(len(localvar.A[0])):\n",
    "                        if abs(localvar.coord-kabels.at[localvar.A[0,localvar.counter],'strtlat'])<0.00001 and abs(ruleA-localvar.A[0,localvar.counter])>0.51: #check coord for which cable is connected and same cable is not allowed!\n",
    "                            localvar.coord=kabels.at[localvar.A[0,localvar.counter],'eindlat']\n",
    "                            ruleA=localvar.A[0,localvar.counter] #rule to ensure that the same cable is not picked again\n",
    "#                             MEGACOUNTER+=1\n",
    "#                             print(localvar.row,localvar.column, localvar.coord)\n",
    "                            # first North component\n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlat'] < kabels.at[localvar.A[0,localvar.counter],'eindlat']:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]*-1\n",
    "                            else:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]\n",
    "                            # now East component    \n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlon'] < kabels.at[localvar.A[0,localvar.counter],'eindlon']:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]*-1\n",
    "                            else:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]\n",
    "                            break                           \n",
    "                        elif abs(localvar.coord-kabels.at[localvar.A[0,localvar.counter],'eindlat'])<0.00001 and abs(ruleA-localvar.A[0,localvar.counter])>0.51:\n",
    "                            ruleA=localvar.A[0,localvar.counter]\n",
    "#                             MEGACOUNTER+=1\n",
    "                            localvar.coord=kabels.at[localvar.A[0,localvar.counter],'strtlat']\n",
    "#                             print(localvar.row, localvar.column, localvar.coord)\n",
    "                            # first North component\n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlat'] < kabels.at[localvar.A[0,localvar.counter],'eindlat']:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]\n",
    "                            else:\n",
    "                                localvar.stat_voltN[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],0]*-1\n",
    "                            # now East component    \n",
    "                            if kabels.at[localvar.A[0,localvar.counter],'strtlon'] < kabels.at[localvar.A[0,localvar.counter],'eindlon']:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]\n",
    "                            else:\n",
    "                                localvar.stat_voltE[localvar.row,localvar.column]+=localvar.E_kabels[localvar.A[0,localvar.counter],1]*-1\n",
    "                            break\n",
    "                        else:\n",
    "                            pass\n",
    "#         print(localvar.row,NEWCOUNTER)\n",
    "#     print(f'Amount of cables is {MEGACOUNTER/2}')\n",
    "#                         else:\n",
    "#                             print(localvar.row, localvar.column, 'error')\n",
    "    for localvar.row,localvar.line in enumerate(trafo_connect):\n",
    "        for localvar.column,localvar.item in enumerate(localvar.line):\n",
    "            localvar.J_north[localvar.row]+=localvar.stat_voltN[localvar.row,localvar.column]*trafo_cond[localvar.row,localvar.column]*-1*-1 #extra -1 -1 to get J in opposite direction of E\n",
    "            localvar.J_east[localvar.row]+=localvar.stat_voltE[localvar.row,localvar.column]*trafo_cond[localvar.row,localvar.column]*-1*-1\n",
    "    return localvar.J_north, localvar.J_east"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calcE(kabels,EX_matrix,EY_matrix,lat,lon,time): #E for all cables\n",
    "    from scipy.interpolate import griddata\n",
    "    from scipy.integrate import simps\n",
    "    localvar.heading=np.zeros(len(kabels))\n",
    "    localvar.old=np.zeros((len(kabels),2))\n",
    "    nr=40 # amount of nodes\n",
    "    while True:\n",
    "        localvar.E_all=np.zeros((len(kabels),2))\n",
    "        localvar.latrange=np.zeros((len(kabels),nr))\n",
    "        localvar.lonrange=np.zeros((len(kabels),nr))\n",
    "        localvar.GridEX=np.zeros((len(kabels),nr))\n",
    "        localvar.GridEY=np.zeros((len(kabels),nr))\n",
    "    \n",
    "        for number in range(len(kabels)):\n",
    "            localvar.latrange[number,:]=np.linspace(kabels.at[number,'strtlat'],kabels.at[number,'eindlat'],nr) \n",
    "            localvar.lonrange[number,:]=np.linspace(kabels.at[number,'strtlon'],kabels.at[number,'eindlon'],nr) \n",
    "            localvar.heading[number]=kabels.at[number,'heading']\n",
    "        localvar.GridEX=griddata((lat,lon),EX_matrix[time,:],(localvar.latrange,localvar.lonrange),method='cubic') #interpolate value\n",
    "        localvar.GridEY=griddata((lat,lon),EY_matrix[time,:],(localvar.latrange,localvar.lonrange),method='cubic')\n",
    "        for number in range(len(kabels)):\n",
    "            localvar.E_all[number,0]+=abs(np.cos(np.radians(localvar.heading[number])))*simps(localvar.GridEX[number,:],np.linspace(0,kabels.at[number,'length'],nr))\n",
    "            localvar.E_all[number,1]+=abs(np.sin(np.radians(localvar.heading[number])))*simps(localvar.GridEY[number,:],np.linspace(0,kabels.at[number,'length'],nr))\n",
    "        print(nr, np.sum(abs(localvar.old-localvar.E_all)))\n",
    "        if np.sum(abs(localvar.old-localvar.E_all))<10**-5:\n",
    "            print('Iterations used', nr-1)\n",
    "            break\n",
    "        else:\n",
    "            localvar.old[:,0]=localvar.E_all[:,0]\n",
    "            localvar.old[:,1]=localvar.E_all[:,1]\n",
    "            nr+=1\n",
    "    return localvar.E_all"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
